Операционные системы .
. https://ru.hexlet.io/courses/cli-basics/lessons/operating-systems/theory_unit
Командная строка .
. https://ru.hexlet.io/courses/cli-basics/lessons/command-line/theory_unit
Навигация .
. https://ru.hexlet.io/courses/cli-basics/lessons/navigation/theory_unit
Интерфейс командной строки .
. https://ru.hexlet.io/courses/cli-basics/lessons/command-line-interface/theory_unit
Файловая структура .
. https://ru.hexlet.io/courses/cli-basics/lessons/filestructure/theory_unit
Чтение файлов .
. https://ru.hexlet.io/courses/cli-basics/lessons/read-files/theory_unit
Поиск .
  Grep .
  . https://ru.hexlet.io/courses/cli-basics/lessons/grep/theory_unit
  Find .
  . https://ru.wikipedia.org/wiki/Find
Редактирование файлов .
. https://ru.hexlet.io/courses/cli-basics/lessons/edit-files/theory_unit  
  Vim .
  . https://guides.hexlet.io/vim/  `Зачем использовать vim`
  Sed (Stream Editor) .
  . https://ru.wikipedia.org/wiki/Sed
Потоки .
  . https://ru.hexlet.io/courses/cli-basics/lessons/streams/quiz_unit


Полезное .
   https://explainshell.com/, достаточно вбить любую команду, и он покажет удобное интерактивное описание.
   https://ru.wikipedia.org/wiki/Регулярные_выражения [регулярные выражения#]



. Задолго до появления `Windows`, в 70-х годах двадцатого века на свет появилась 
  операционная система Unix, предназначенная для работы на мейнфреймах. 
  Изначальным названием системы было `UNICS` (Uniplexed Information and Computing Service), 
  но в итоге её стали называть `Unix`. В те времена не существовало персональных компьютеров. 
  Компьютеры отождествлялись с `мейнфреймами` — большими машинами, занимающими целые этажи зданий.
. В 1991 году студент Линус Торвальдс решил написать свою собственную свободную операционную 
  систему, которая совместима со стандартом POSIX.  
. `Терминал` называют программу, которая эмулирует поведение "железного" терминала, 
           состоящего из клавиатуры и монитора.  
. `Командный интерпретатор` 
. Командная оболочка и терминал — не одно и то же. Терминал — это программа, 
  которая запускает командную оболочку внутри себя.   
. `Командную оболочку` нередко называют реплом (`REPL, Read-Eval-Print-Loop`), 
 что отражается в способе взаимодействия с пользователем:
`Read` — шелл ждёт ввода команды от пользователя
`Eval` — шелл исполняет введённую команду
`Print` — шелл выводит результат
`Loop` — возвращаемся к первому пункту       

Наигация .
* В начале нет диска, но есть единый корневой каталог |/|. Это вершина файловой 
  системы, все остальные файлы и директории лежат внутри этого корня.
* Вместо обратных слешей |\| используются прямые |/|.
  Working directory .
  . Дерикторя в которой находимся.
    pwd .
    . "print working directory"
    | $ pwd
    | /Users/guest
    ls .
    . программа, которая выводит список файлов и директорий в рабочей (текущей) директории.
    | $ ls
    | Desktop  Documents Downloads Library  Movies  Music  Pictures Public
    cd .
    . "change directory"
    . cd понимает и абсолютные, и относительные пути.
    . cd, выполненная без аргументов, перебрасывает в домашнюю директорию текущего 
      пользователя.
    # Выход на два уровня вверх
    | Music$ cd ../..
    | $ pwd
/Users
# Входим в директорию
| $ cd Music
# Смотрим её содержимое
| Music$ ls
|iTunes
# Смотрим текущую рабочую директорию
| Music$ pwd
| /Users/guest/Music    
`Абсолютный путь` — это полный путь начиная от корня, в нашем случае |/|
`Относительный` — это путь, начинающийся от нашей текущей рабочей директории.
. |~|(тильда), которое в момент выполнения команды заменяется на `абсолютный путь`. 
  Поэтому из любого места можно сделать прямой переход в любую 
  поддиректорию домашней директории.
| <из любого места>$ cd ~/Music
| Music$ pwd
| /Users/guest/Music
Интерфейс командной строки .
. `GUI` (Graphical User Interface — графический интерфейс) 
  `CLI` (Command Line Interface — интерфейс командной строки)
* ls Music, Music — это аргумент  
* ls -a, -a — это опция(флаг)
  опции можно комбинировать
  опции указываются слева от аргументов
  man .
  . (manual) 
  | man <имя команды>
Файловая структура .
  stat .
  . "file system status" информация о любом файле или директории
  | $ stat .bashrc
  | File: '.bashrc'
  | Size: 3771        Blocks: 8          IO Block: 4096   regular file
  | Device: ca01h/51713d    Inode: 259234      Links: 1
  | Access: (0644/-rw-r--r--)  Uid: ( 1002/kirill.m)   Gid: ( 1002/kirill.m)
  | Access: 2018-08-27 17:24:11.237498138 +0000
  | Modify: 2015-08-31 23:27:45.000000000 +0000
  | Change: 2018-01-22 08:13:27.611966864 +0000
  |  Birth: -
FHS .
. FHS (англ. `Filesystem Hierarchy Standard`, «стандарт иерархии файловой системы»)
  — стандарт, унифицирующий местонахождение файлов и каталогов с общим назначением 
  в файловой системе `UNIX`.
. https://ru.wikipedia.org/wiki/FHS  
* `Hard Link` — дополнительное имя для уже существующего файла.
* `Symbolic link` — символическая ссылка, такой файл похож на ярлык в Windows. 
   Если удалить основной файл, то символическая ссылка начнёт вести в никуда.
* `Socket` — специальный файл, через который происходит взаимодействие между 
   разными процессами операционной системы. Программисты постоянно 
   сталкиваются с сокетами в реальной жизни.
Чтение файлов .
  cat .
  . Самый простой способ прочитать файл
  head .
  . Первые 10 строк или другое кол-во 
  tail .
  . Последние 10 строк или другое кол-во
  | $ tail -n 2 .bashrc
  | fi
  | fi
  |tail -f path/to/file| не просто выводит последние строчки файла, но ждёт 
   появления новых. Как только файл дописывается, tail сразу 
   выводит на экран добавленные строки.
  Логи .
  . (иногда говорят "`журналы`") — это текстовые файлы, в которые заносится 
    информация о происходящих процессах в определённой системе. В 
    Linux логи лежат в каталоге |/var/log|. Туда пишет как сам Linux, так и 
    большая часть установленных программ. Основной файл логов Linux 
    называется |syslog|. Туда попадает ключевая информация о происходящих 
    процессах в операционной системе и возникающих ошибках.   
  Пейджеры .
  . Особая категория программ для просмотра содержимого файла.
    less .
    . Самый распространённый пейджер.
     |less| предоставляет несколько десятков команд для перемещения по тексту 
      и его поиску, про большинство из них можно прочитать в соответствующем 
      мануале. Здесь же затронем основные:
      |q| — выход
      |f| — вперёд на страницу
      |b| — назад на страницу
      если набрать |/|, затем начать вводить буквы и нажать Enter, то 
      выполнится поиск введённого текста. Перемещение по найденным совпадениям 
      выполняется командой |n| (переход к следующему совпадению) и 
      командой |N| (переход к предыдущему совпадению).
Grep .
. "global regular expression print"   
| $ man grep
|  
| SYNOPSIS
|        grep [OPTIONS] PATTERN [FILE...]
|        grep [OPTIONS] [-e PATTERN]...  [-f FILE]...  [FILE...]
* `PATTERN` — это то, что ищется, необязательно конкретная строчка, возможно определённый 
   шаблон (см. [#регулярные выражения]). 
* `FILE` — путь до файла, в котором нужно искать   
. Поиск всех строк в файле .bashrc, в которых встречается слово aliases
| $ grep aliases .bashrc
| # enable color support of ls and also add handy aliases
| # some more ls aliases
| # ~/.bash_aliases, instead of adding them here directly.
| if [ -f ~/.bash_aliases ]; then
|     . ~/.bash_aliases
. Количество выводимых соседних строк регулируется опциями |-B|, |-A| и |-C|. 
  Первая определяет количество отображаемых строк до искомой (|-B|, |--before-context|), 
  вторая — после (|-A|, |--after-context|), а 
  третья — до и после одновременно (|-C, --context|). 
  Ниже пример использования |-C| со значением 1. Это значит, что для каждой найденной 
  строки будет выведена одна строка выше и одна строка ниже.
. Ниже пример использования -C со значением 1. Это значит, что для каждой найденной 
  строки будет выведена одна строка выше и одна строка ниже.
| $ grep -C 1 aliases .bashrc
|  
| # enable color support of ls and also add handy aliases
| if [ -x /usr/bin/dircolors ]; then
| --
|  
| # some more ls aliases
| alias ll='ls -alF'
| --
| # You may want to put all your additions into a separate file like
| # ~/.bash_aliases, instead of adding them here directly.
| # See /usr/share/doc/bash-doc/examples in the bash-doc package.
|  
| if [ -f ~/.bash_aliases ]; then
|     . ~/.bash_aliases
| fi
. Иногда мы не знаем, в каком файле то, что мы ищем, но знаем директорию, 
  в которой лежит этот файл. В такой ситуации нужно сделать два изменения:
  1. Добавить опцию |-R|, которая говорит о том, что надо искать внутри 
  директории (рекурсивно, то есть включая все поддиректории).
  2. Указать путь до директории, а не файла.
| $ grep -R bashrc . 
| ./.profile:    # include .bashrc if it exists
| ./.profile:    if [ -f "$HOME/.bashrc" ]; then
| ./.profile: . "$HOME/.bashrc"
| ./.bash_history:du -sh .bashrc
| ./.bash_history:stat .bashrc
. При таком поиске в выводе указывается файл, в котором была найдена строка. 
  Если добавить опцию |n|, то дополнительно отобразится номер строки.
$ grep -Rn bashrc .
| ./.profile:13:    # include .bashrc if it exists
| ./.profile:14:    if [ -f "$HOME/.bashrc" ]; then
| ./.profile:15:  . "$HOME/.bashrc"
| ./.bash_history:56:du -sh .bashrc
| ./.bash_history:57:stat .bashrc
| ./.bash_history:58:stat -h .bashrc
| ./.bash_history:60:file .bashrc
Find .
. |find| — утилита поиска файлов по имени и другим свойствам, используемая в 
   UNIX‐подобных операционных системах. Может производить поиск в одном или 
   нескольких каталогах с использованием критериев, заданных пользователем. 
   По умолчанию |find| возвращает все файлы в рабочем каталоге. 
   Более того, |find| позволяет применять пользователю определённые действия 
   ко всем найденным файлам. Также поддерживаются регулярные выражения. 
   Для поиска файлов по содержимому следует пользоваться утилитой |grep|.
Редактирование файлов .
  Nano .
  . |Nano| очень простенький текстовый редактор, похожий на "блокнот" в Windows,
     хотя по возможностям он богаче и даже способен подсвечивать содержимое файлов.
  | $ nano .bashrc
  | Nano
    После запуска редактора внизу открывается панель с подсказками, 
    какие горячие клавиши доступны для использования. Символ |^| означает 
    клавишу |Ctrl|. Например, для выхода из редактора нужно набрать |Ctrl + x|, 
    а затем либо подтвердить сохранение изменений, либо отвергнуть, нажав 
    `y` (`yes`) или `n` (`no`). 
  Vim .
  . Vim (Vi Improved или улучшенный vi) — свободный текстовый редактор, созданный 
    на основе более старого vi (visual editor). Это редактор-комбайн, который, 
    к тому же, имеет абсолютно непохожую ни на что другое модель работы.
  | $ vim .bashrc
  | Vim
    Как выйти .
    . Уедитесь, что вы находитесь в командном режиме, на всякий случай нажмите `Esc` 
      (или комбинацию `Ctrl + [`). Затем наберите `:`, эта команда переведёт вас в 
      режим командной строки (ещё один режим), затем введите `q!` и нажмите `Enter`. 
      Так вы выйдете из вима без сохранения изменений. 
      Если набрать `:wq`, то перед выходом сохранятся все изменения. Если вы 
      хотите просто сохраниться без выхода, то наберите `:w`.
    В Vim есть четыре основных режима работы: .
      1. `Командный режим` (обычный режим) — это режим по умолчанию. Перемещение по файлу, 
          быстрое (при помощи команд, комбинаций клавиш) 
          редактирование, удаление, поиск текста. |esc| or |ctrl + [|
      2. `Режим вставки` (режим ввод) — ввод текста с клавиатуры. То, как вы привыкли 
          это делать в обычных редакторах. Нажать |i|.
      3. `Визуальный режим` — выделение произвольных участков текста.
      4. `Режим командной строки` — собственная командная строка для редактора текста, 
          из которой можно выполнять великое множество разнообразных команд.
Потоки .
  STDOUT стандартного вывод .
    |>| .
    . Перенаправление потока.
    | $ ls -la > output
      Запустив эту команду, вы увидите, что на экране ничего не отобразилось, но в 
      текущей директории появился файл `output`.
    | $ cat output
    | total 44
    | drwxr-xr-x 5 kirill.m kirill.m 4096 Aug 29 09:39 . 
    | drwxr-xr-x 8 root     root     4096 Apr 26 10:38 ..
    | -rw------- 1 kirill.m kirill.m 1822 Aug 29 08:45 .bash_history
    | -rw-r--r-- 1 kirill.m kirill.m  220 Aug 31  2015 .bash_logout
    | -rw-r--r-- 1 kirill.m kirill.m 3771 Aug 31  2015 .bashrc
    | drwx------ 2 kirill.m kirill.m 4096 Mar 30 18:10 .cache
    . Символ |>| означает, что нужно взять вывод из команды, указанной слева, и 
      отправить его в файл, указанный справа. |>| всегда `перезаписывает` файл. 
      Такое перенаправление работает с абсолютно любой командой, 
      которая выводит результаты своей работы на экран.
    | $ grep alias .bash_profile > result
    | $ cat result
    | alias fixssh='eval $(tmux showenv -s SSH_AUTH_SOCK)'
    |>>| .
    . Если нужно не перезаписывать, а добавлять, то используйте |>>|.
      STDOUT, который уже можно перенаправлять.
  STDIN (стандартный ввод) .
  . |STDIN| работает в обратную сторону: через него программа может 
    получать данные на вход.
  STDERR (вывод ошибок) .
  . Как и |STDOUT|, по умолчанию идёт на экран. |STDERR| позволяет отделить 
    нормальный вывод программы от возникающих ошибок. Такой подход удобен при 
    ведении логов, для реагирования и отладки. Будьте осторожны, 
    перенаправление вывода в файл перенаправляет только |STDOUT|. 
    Убедиться в этом очень просто. 
    Если попробовать перейти в несуществующую директорию, то команда |cd| 
    выдаст ошибку:
  
. В *nix-системах встроена утилита |wc| (word count — "количество слов"), 
  которая умеет считать количество слов, строк или символов в файле. 
  Когда мы говорим о файле, то в *nix это почти всегда означает, 
  что данные можно передать и в стандартный поток ввода.
. Флаг `l` (l а не 1) говорит о том, что надо считать количество строк
| $ wc -l < result
| 2
  Выглядит довольно логично — стрелка меняет своё направление в другую сторону 
  и содержимое файла отправляется в STDIN запускаемой программы |wc|. 
. Теперь сделаем финт и объединим перенаправление ввода и вывода.
| $ wc -l < result > output
| $ cat output
| $ 2
Process .
. Последний вопрос связан с тем, зачем нужен поток |STDERR|. Он, как и |STDOUT|, 
  по умолчанию идёт на экран. |STDERR| позволяет отделить нормальный вывод 
  программы от возникающих ошибок. Такой подход удобен при ведении логов, 
  для реагирования и отладки. Будьте осторожны, перенаправление вывода в 
  файл перенаправляет только |STDOUT|. Убедиться в этом очень просто. 
  Если попробовать перейти в несуществующую директорию, то команда |cd| выдаст ошибку:
| $ cd lala
| -bash: cd: lala: No such file or directory
. Теперь попробуем перенаправить вывод в файл output
| $ cd lala > output
| -bash: cd: lala: No such file or directory
  Перенаправление есть, но сообщение вывелось на экран. Это произошло именно 
  по той причине, что |STDERR| остался привязан к экрану, а внутри файла 
  output — пустота. Решить эту задачу можно несколькими способами. 
  Например, перенаправив |STDERR| в |STDOUT|, либо отправив их оба в файл.

  Перенаправление STDERR в STDOUT .
  . Сначала |STDERR| перенаправляется в |STDOUT|, затем |STDOUT| в файл
  | $ cd lala > output 2>&1
  | $ cat output
  | -bash: cd: lala: No such file or directory
    В данном случае обозначает номер потока. В POSIX за каждым потоком 
    закреплён определённый номер, который является файловым дескриптором, 
    если быть точным: `STDIN — 0`, `STDOUT — 1`, `STDERR — 2`. 
    Конструкцию `2>&1` нужно просто запомнить, она говорит о том, 
    что поток с номером 2 отправляем в поток с номером 1.
  . Перенаправление STDERR бывает полезно само по себе, без вывода в файл.
  .  |STDERR| просто перенаправляется в другой поток (STDOUT)
  | $ cd lala 2>&1
  | -bash: cd: lala: No such file or directory
  Перенаправление конкретного потока в файл .
  . Чтобы перенаправить конкретный поток, нужно указать его номер перед |>|.
  . Таким образом можно сразу перенаправить STDERR в файл
  | $ cd lala 2> output 
  | $ cat output
  | -bash: cd: lala: No such file or directory
  Перенаправление обоих потоков в файл .
  . Этот вариант используется наиболее часто, так как помогает легче проводить 
    отладку и понимать почему вообще возникла та или иная ошибка.
  . Оба потока, STDERR и STDOUT, перенаправляются в файл
  | $ cd lala &> output
  | $ cat output
  | -bash: cd: lala: No such file or directory
    

  



  



