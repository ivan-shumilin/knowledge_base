Задачи .
  [to_roman_to_arabic] .
  . Переводит арабское число в римское
  [to_arabic_to_roman] .
  . Римское в арабское 
Словарь [Dict] .
. |Словарь|, или как ещё говорят, |ассоциативный массив| — тип данных, представляющий
   собой коллекцию пар "ключ-значение". В рамках одного словаря ключи не повторяются.
Особенности .
. Коллекции, о которых говорилось ранее, а именно — списки и кортежи — упорядочены
  и хранят элементы в том порядке, в котором они были добавлены. Словарь же не таков:
  он не запоминает порядок добавления элементов и вместо этого сохраняет элементы так,
  чтобы операции над содержимым словаря были максимально эффективны!
. Строго говоря, в Python 3, начиная с версии 3.7, поменялось внутреннее устройство
  словарей: начиная с этой версии словари помнят, в каком порядке ключи добавлялись.
  Однако "завязывать" логику на этом свойстве не стоит — для хранения порядка чего-либо
  больше подходят списки.
. Элементы списка или кортежа индексированы и позиция каждого элемента представляет
  собой число — порядковый номер от начала коллекции. Ключами же словаря могут быть не
  только числа, но и многие другие типы данных, чаще всего — строки. И если индексы 
  списка и кортежа монотонны — идут без пропусков, у соседних элементов отличаются на 
  единицу, то никаких особых закономерностей между ключами словаря нет 
  (кроме гарантии уникальности).
. Обычно списки |гомогенны|, т.е. хранят элементы одного типа. Словари же, напротив, 
  чаще всего |гетерогенны|: отличаться могут как типы значений, так и типы ключей — да, 
  бывает и такое, хоть и редко :)
Литерал словаря .
| dictionary = {
|     "foo": "bar",
|     "baz": 42,
|     "items": {
|         1: "apple",
|         2: "orange",
|         100500: "lemon"
|     },
| }
| dictionary
| {'foo': 'bar', 'baz': 42, 'items': {1: 'apple', 2: 'orange', 100500: 'lemon'}}
. И переменные, конечно же, могут выступать в роли значений и ключей:
| key, val = 'x', 42
| {key: val}
| {'x': 42}
Доступ к элементам по ключу .
. Выше я объявил словарь dictionary. Запросить у него значение по ключу можно так:  
| dictionary["baz"]
| 42
| dictionary["BANG"]
| ...
| KeyError: 'BANG'
. Ключа "BANG" в dictionary нет, поэтому было возбуждено исключение
  KeyError — аналог IndexError, только для словарей.  
. Проверить наличие ключа в словаре можно с помощью привычного оператора |in|:

| >>> "baz" in dictionary
| True
| >>> "BANG" in dictionary
| False
. Теперь, если вы захотите получить значение по ключу, которого может и не быть, 
  вы можете сделать это так:  
| dictionary["BANG"] if "BANG" in dictionary else None
  Однако подобный "безопасный" запрос элементов нужен настолько часто, что объект
  словаря имеет для этого специальный метод |.get|:  
  | dictionary.get("baz")
  | 42
  | dictionary.get("BANG")  # вернёт None
  | dictionary.get("BANG", "no such key")
  | 'no such key'
  Третий вызов метода показывает, как можно явно задать значение по-умолчанию.
  Если его не указывать, метод вернёт None при отсутствии значения по указанному ключу.
Итераторы [keys], [values] и [items] .
. Если попробовать проитерировать словарь, то мы получим перечень ключей:  
| for k in {"a": 1, "b": 2}:
|      print(k)
| a
| b
  Keys .
  . Этого же результата можно добиться и более явно, для чего нужно будет вызвать метод |.keys()|:
  list({"a": 1, "b": 2}.keys())
  ['a', 'b']
  Values .
  . Чтобы получить значения, нужно вызвать метод |.values()|:
  list({"a": 1, "b": 2}.values())
  [1, 2]
  Items .
  . А чтобы получить одновременно и ключи и соответствующие значения, можно вызвать метод |.items()|:

  | for k, v in {"a": 1, "b": 2}.items():
  |     print(k, "=", v)
  | a = 1
  | b = 2
Изменение данных в словаре .
  Поэлементное изменение словаря .
  . Словарь в Пайтоне — изменяемый (|мутабельный|). Однако для добавления новой пары ключ-значение 
    не нужны отдельные методы, вроде спискового метода |.append| — достаточно обычного присваивания:
  | d = {}  # пустой словарь
  | d["a"] = 100
  | d  # {'a': 100}
  | d["b"] = 200
  | d["a"] = 0
  | d  # {'a': 0, 'b': 200}
  Pop .
  . Здесь вы можете увидеть, что присваивание значения новому ключу выглядит точно так же, как и 
    присваивание существующему. Удобно!
  . Удаление элементов из словаря делается с помощью метода |pop| — в этом словарь уже больше похож 
    на список. Только вместо индекса используется ключ:
  | d = {'a': 1, 'b': 2}
  | d.pop('a') #  1
  | d  # {'b': 2}
  | d.pop('BANG')
  | KeyError: 'BANG'
  . Пример показывает, что если попытаться извлечь значение по несуществующему ключу, то будет 
    возбуждено исключение. Однако метод |pop| можно вызывать с указанием значения по умолчанию. 
    В этом случае при отсутствии ключа в словаре будет возвращено это самое значение, а исключение 
    возбуждено не будет. Пример:
  | d = {'a': 1, 'b': 2}
  | d.pop('BANG', None)
  | d.pop('BANG', 42)
  | 42
  Popitem .
  . Аналогом спискового |pop| без аргументов для словаря служит метод |popitem|. Этот метод извлекает 
    ключ и значение в виде кортежа, а если словарь уже пуст, то возбуждает исключение:
  | d = {'a': 1}
  | d.popitem()  # ('a', 1)
  | d.popitem()  # KeyError: 'popitem(): dictionary is empty'
  . Помним, что порядок ключей в словаре не зависит от того, в какой последовательности эти ключи 
    добавлялись в словарь. Поэтому мы не можем полагаться на то, в каком порядке будут возвращаться 
    пары при вызове |popitem|! Но в том, что все пары будут извлечены и каждая пара будет извлечена 
    строго один раз, мы можем быть уверены :)

Дополнение одного словаря другим .
  Update .
  . У списка есть метод |extend|, который расширяет один список другим. У словаря есть похожий по смыслу 
    метод |update|. Однако, при вызове |update| ассоциированный объект словаря не просто получает пары 
    ключ-значение из нового словаря. Происходит именно обновление данных (поэтому метод и называется 
    |update|): новые ключи дописываются в словарь, а если какие-то ключи уже существовали до этого, то 
    значения, с ними связанные, будут заменены новыми. Пример:
  | cart = {'apples': 2, 'oranges': 1}
  | addon = {'oranges': 5, 'lemons': 3}
  | cart.update(addon)
  | cart
  | {'apples': 2, 'oranges': 5, 'lemons': 3}
    Лимоны были добавлены, а количество апельсинов было обновлено. Просто, понятно, удобно.
Копирование словаря .
  Copy .
  . В случае списков мы можем сложить два списка и получить новый. Или же получить копию 
    одного списка и уже её дополнить данными из второго. Но словари нельзя складывать и 
    срезы словари тоже не поддерживают. Зато у словаря есть метод |copy|, который работает 
    аналогично копированию списка с помощью среза [:] — при вызове он возвращает так называемую 
    |поверхностную копию| (она же |"неглубокая копия"|, |"shallow copy"|) словаря. Поверхностная копия 
    воспроизводит только структуру словаря, но не копирует значения, а только лишь создаёт на них 
    новые ссылки. И тем не менее поверхностная копия — новый словарь, который может изменять 
    свой состав, не влияя на оригинал:
  | d = {'a': 1, 'b': [42]}
  | c = d.copy()
  | c.update({'a': 10, '1k': 1024})
  | c  # {'a': 10, 'b': [42], '1k': 1024}
  | c['b'].append(None)
  | c  # {'a': 10, 'b': [42, None], '1k': 1024}
  | d  # {'a': 1, 'b': [42, None]}
    Словарь c получил свою собственную структуру и его обновление не затронуло оригинальный 
    словарь |d|. Однако изменение объекта списка по ссылке затронуло и оригинал, потому 
    что при копировании словаря ссылка на список тоже скопировалась!
Очистка словаря .
  Clear .
  . Списки мы можем очистить с помощью присваивания срезу (l[:] = []). В случае словаря вместо 
    присваивания срезу используется метод |clear|:
   
  | d = {'a': 1}
  | d.clear()
  | d  # {}
    Метод |clear| очищает словарь "по месту", конечно же.    
Инициализация новых значений .
  .setdefault .
  . Представьте ситуацию: вам нужно хранить в словаре в качестве значений что-нибудь изменяемое, 
    скажем, списки. И вот в процессе работы с таким словарём вы попадаете в ситуацию, 
    когда у вас есть ключ и элемент для добавления в список-значение, 
    но — вот ведь незадача — ключ пока в словаре не представлен. Приходится писать подобный код:
    | if key not in dictionary:
    |     dictionary[key] = []  # инициализируем список
    | dictionary[key].append(value)  # изменяем список
  . Подобная ситуация встречается не так уж и редко. Это понимали и авторы стандартной библиотеки 
    Python и дали словарю метод |setdefault|. Вышеупомянутый код можно переписать с использованием 
    этого метода:
    | dictionary.setdefault(key, []).append(value)
    Компактно и лаконично! Но что же делает метод |setdefault|? Метод принимает ключ и значение 
    по умолчанию и возвращает ссылку на значение в словаре, связанное с указанным ключом. А если 
    ключ в словаре отсутствует, то метод помещает по ключу то самое значение по умолчанию 
    и возвращает ссылку на него!
    В примере выше значением по умолчанию выступает пустой список [].
  Defaultdict .
  . В стандартной поставке Python присутствует модуль |collections|. Этот модуль, помимо прочего, 
    предоставляет тип |defaultdict|. |defaultdict| — это во всех отношениях обычный словарь, 
    но обладающий одним уникальным свойством: там, где словарь "ругается" на отсутствие ключа, 
    |defaultdict| сам возвращает значение по умолчанию. Давайте рассмотрим пример:
  | from collections import defaultdict
  | d = defaultdict(int)
  | d['a'] += 5
  | d['b'] = d['c'] + 10
  | d
  | defaultdict(<class 'int'>, {'a': 5, 'c': 0, 'b': 10})
    При создании словаря я указал в качестве аргумента функцию |int|. Если эту функцию вызвать без 
    аргументов, то она вернёт 0 и именно этот вызов внутри словаря d и происходит всякий раз, 
    когда нужно получить значение для несуществующего ключа. Поэтому d['a'] += 5 даёт в итоге 5, 
    т.к. сначала для ключа 'a' создаётся начальное значение (делается вызов int() и получается 0), 
    а потом к нему прибавляется 5. В строчке d['b'] = d['c'] + 10 создаются значения для 
    ключей 'b' и 'c' и затем уже по ключу 'b' записывается сумма 0 + 10.
  . Вот ещё один пример — на этот раз с самодельной функцией-инициализатором:
  | >>> def new_value():
  | ...     return 'foo'
  | >>> x = defaultdict(new_value)
  | >>> x[1]
  | 'foo'
  | >>> x['bar']
  | 'foo'
  | >>> x
  | defaultdict(<function new_value at 0x7f2232cf5a60>, {1: 'foo', 'bar': 'foo'})
  . Если отбросить немного непонятное упоминание функции-инициализатора, видно, что по всем ключам, 
    по которым я обращался к содержимому словаря, теперь записаны строки 'foo'.
  . Отличия |defaultdict| от обычного словаря c |setdefault|
  . Зачем же иметь оба способа, если они настолько похожи, спросите вы. Но давайте сравним эти две строки:
  | a.setdefault(key, []).append…
  | # vs
  | b[key].append…
  |   
  | # b это defaultdict(list)
  . Строки очень похожи, но если во втором случае новый список создаётся только тогда, когда ключ не будет 
    найден, то в первой строчке объект пустого списка будет создаваться каждый раз. 
    Так как значения аргументов всегда вычисляются до того как будет вызвана функция, в данном 
    случае |setdefault(key, [])|. Конкретно затратами на создание пустого списка можно пренебречь. 
    Однако, если вдруг затраты на создание значения по умолчанию окажутся велики, скажем, 
    каждое создание потребует хождения в базу данных, то вариант с |defaultdict| сразу же окажется 
    гораздо более предпочтителен!
  . Зачем же вообще использовать |setdefault?| Например для того, чтобы по разным ключам инициализировать 
    разные значения! Т.к. значение по-умолчанию передаётся каждый раз, мы можем по разным ключам хранить 
    даже разные типы данных. С |defaultdict| у нас нет контроля над тем, какие значения по каким ключам 
    класть: функция-инициализатор вызывается каждый раз одна и та же и ключ в неё не передаётся.
  . Наконец всегда остаются редкие случаи, когда и |defaultdict| не подходит, потому что нужно 
    инициализировать значения по-разному, но не подходит и |setdefault| — новые значения неизменяемы и их 
    не получится изменить по возвращаемой ссылке. Пример такого случая (вместе с решением задачи 
    ненахождения ключа):
  | x['count'] = x.get('count', 0) + 1
  | x['path'] = x.get('path', '') + '/' + dir
    Да, здесь присутствуют лишние хождения по одному и тому же ключу, но сам код читается неплохо и в 
    данной ситуации, можно сказать, оптимален!

