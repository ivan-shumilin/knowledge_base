[https://ru.hexlet.io/courses/python-lists/lessons/slices/theory_unit]
Срезы—
работать с одиночными элементами вы уже умеете. Настало время перейти к очень интересному инструменту, который Python предоставляет для работы с целыми подмножествами элементов списка: к так называемым срезам (slices).

Синтаксис описания срезов
Срезы встроены в язык и снабжены своим собственным синтаксисом — настолько широко они используются. Срез записывается так же, как записывается обращение к элементу списка по индексу:

some_list[START:STOP:STEP]
Всего у среза три параметра:

START — индекс первого элемента в выборке,
STOP — индекс элемента списка, перед которым срез должен закончиться (т.е. сам элемент с индексом STOP не будет входить в выборку),
STEP — шаг прироста выбираемых индексов.
Математически говоря, индексы элементов, которые будут выбраны, входят в множество

[START, START + STEP, START + 2 * STEP, .., STOP]
Например, срез [3:20:5] означает выборку значений с индексами 3, 8, 13 и 18.

При этом любой из трёх параметров среза может быть опущен и вместо соответствующего параметра будет выбрано некое значение по умолчанию:

умолчательный START означает "от начала списка",
умолчательный STOP означает "до конца списка" (включительно),
умолчательный STEP означает "брать каждый элемент".
Вот несколько примеров с разными наборами параметров:

[:]/[::] — "весь список",
[::2] — "нечётные по порядку элементы",
[1::2] — "чётные по порядку элементы",
[::-1] — "все элементы в обратном порядке",
[5:] — "все элементы, начиная с шестого",
[:5] — "все элементы, не доходя до шестого",
[-2:1:-1] — "все элементы от предпоследнего до третьего в обратном порядке" (во всех случаях выборки от большего индекса к меньшему нужно указывать шаг!).
Срезы могут работать в двух режимах: собственно выборка и присваивание.

Выборка элементов
Срезы-выборки работают со списками, кортежами, строками. Результатом применения выборки всегда становится новое значение соответствующего типа — список, кортеж, строка. Пример:

>>> 'hello'[2:]
'llo'
>>> (1, "foo", True, None)[2:]
(True, None)
>>> [1, 2, 3, 4, 5][2:]
[3, 4, 5]
Сразу сделаю несколько замечаний по использованию выборок:

Так как кортежи чаще всего содержат разнородные элементы, срезы для них менее полезны, чем распаковка и перепаковка: тяжело удерживать в голове типы элементов вместе с индексами.
Т.к. при выборке по срезу [:] создаётся новая копия списка, то именно так обычно список питонисты и копируют :)
Нужно помнить, что хоть срез и порождает новый список или кортеж, для каждого выбранного элемента копируется только ссылка!
Присваивание срезу
В отличие от строк и кортежей списки могут изменяться по месту. Одним из вариантов модификации является присваивание срезу. Срезу с указанным шагом можно присвоить список, содержащий соответствующее (то же, что и в срезе) кол-во новых элементов. Пример:

>>> l = [1, 2, 3, 4, 5, 6]
>>> l[::2] = [0, 0, 0]
>>> l
[0, 2, 0, 4, 0, 6]
Внимание, если вы попробуете присвоить срезу с шагом не то количество элементов, вы получите ошибку:

>>> l = [1, 2, 3, 4]
>>> l[::2] = [5, 6, 7]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: attempt to assign sequence of size 3 to extended slice of size 2
Если же срез непрерывный, т.е. шаг не указан и индексы идут подряд, то свободы нам даётся больше. Такому срезу можно присвоить как больше элементов — тогда список вырастет, так и меньше, что приведёт к урезанию списка. Примеры:

>>> l = [1, 2, 3]
>>> l[2:] = [4, 5]
>>> l
[1, 2, 4, 5]
>>> l[1:-1] = [100]
>>> l
[1, 100, 5]
>>> l[:] = []
>>> l
[]
Сначала список растёт, потом уменьшается, а под конец вообще становится пустым — и всё с помощью компактного, но мощного синтаксиса срезов.

Срезы — значения
Хоть срезы и имеют специальную поддержку со стороны синтаксиса, но мы можем создавать и использовать срезы сами по себе — как обычные значения.

Значение среза можно сконструировать с помощью функции slice:

>>> first_two = slice(2)
>>> each_odd = slice(None, None, 2)
>>> each_odd
slice(None, None, 2)
>>> l = [1, 2, 3, 4, 5]
>>> l[first_two]
[1, 2]
>>> l[each_odd]
[1, 3, 5]
Функция slice принимает от одного до трёх параметров — те самые START, STOP и STEP. Если вы хотите "пропустить" один из параметров, то подставьте вместо него None.

None можно использовать и в записи срезов в квадратных скобках. Там None так же будет означать пропуск значения!

И конечно же на месте параметров среза могут быть любые выражения, лишь бы эти выражения вычислялись в целые числа или None.

Соотношение START и STOP
В срезе элемент с индексом STOP не попадает в выборку, в отличие от элемента с индексом START. У такого поведения есть особенность: какой бы мы ни выбрали неотрицательный индекс n для любого списка — даже выходящий за его пределы — указанное равенство будет соблюдаться:

l == l[:n] + l[n:]
Пример:

>>> s = 'Hello!'
>>> s[:2] + s[2:]
'Hello!'
>>> s[:4] + s[4:]
'Hello!'
>>> s[:0] + s[0:] == s
True
>>> s[:100] + s[100:] == s
True
Это свойство удобно использовать, когда вы разбираете некий текст: вам достаточно двигать позицию "разрезания" строки на начало и остаток, не заботясь о том, что какая-либо информация на границе разрезания потеряется!

